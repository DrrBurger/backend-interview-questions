# Go Interview Questions 2023
Репозиторий предназначен для подготовки к собеседованиям на позицию Backend разработчика.  
В данном Readme собраны (частые и не очень, простые и сложные) вопросы, а так же ответы к ним.  
Вопросы условно делятся на: общие вопросы и вопросы непосредственно по самому языку Go.

# Инструкции по применению
Настоятельно рекомендую, прежде чем открывать ответ на вопрос попробовать ответить на него самостоятельно.  
Если ответить не получается, попробуйте выдумать ответ основываясь на уже имеющихся у вас знаниях.  
И только если вы в полном ступоре открывайте ответ на вопрос.

P.S.
Вы будете благодарны себе если выполните инструкцию в точности как написано.

P.S.S.
- Если вы заметили не точность
- У вас есть свой вопрос который вы добавили бы в список
- Вы недавно проходили собеседование  
  То смело пишите мне я обязательно исправлю/добавлю вопрос/ответ

---
<p style="text-align: center;">
  <img src="https://github.com/DrrBurger/Photos_for_git/blob/master/1_3UreHEOa70zgNwE3JeFoHQ.webp" alt="logo">
</p>

---

# Вопросы и ответы

<!-- ОБЩЕЕ -->
<details>
    <summary><h2><i>Общее</i></h2></summary>

---

Вопрос №1: [ Что такое микросервисы? ]

<details>
  <summary>Ответ</summary>

    - Микросервисы — это подход к разработке программного обеспечения, при котором большое приложение разбивается на меньшие, автономные компоненты. 
    Каждый микросервис представляет собой отдельный модуль, который реализует определенный функционал и может работать независимо от других модулей. 
    Эти модули обычно взаимодействуют друг с другом через API или событийно-ориентированную архитектуру.

</details>

---

Вопрос №2: [ Какие преимущества у микросервисной архитектуры по сравнению с монолитом? А какие недостатки? ]

<details>
  <summary>Ответ</summary>

    - Преимущества:
        - Гибкость: Можно использовать разные технологии и языки программирования для разных микросервисов.
        - Масштабируемость: Легче масштабировать отдельные компоненты.
        - Распределение работы: Разные команды могут работать над разными сервисами параллельно.
        - Быстрый цикл разработки: Изменения в одном микросервисе могут быть развернуты независимо от других.
        
    - Недостатки:
        - Сложность: Взаимодействие между микросервисами может стать сложным и трудным для управления.
        - Проблемы с данными: Труднее обеспечить консистентность данных между сервисами.
        - Сложность тестирования: Тестирование может быть сложнее, особенно для сценариев, которые требуют взаимодействия между множеством сервисов.
</details>

---

Вопрос №3: [ Что использовать для трассировки сервисов? Для мониторинга? А для логирования? ]

<details>
  <summary>Ответ</summary>

    - Трассировка: Jaeger, Zipkin.
    - Мониторинг: Prometheus, Grafana, Zabbix.
    - Логирование: ELK Stack (Elasticsearch, Logstash, Kibana), Grafana Loki.
</details>

---

Вопрос №4: [ Как быть с консистентностью данных между несколькими микросервисами? ] <a name="micro2"></a>

<details>
  <summary>Ответ</summary>

    - Консистентность данных в микросервисной архитектуре — сложная задача. Один из подходов — использование распределенных транзакций, но это может привести к проблемам производительности и доступности. 
      Другой подход — "eventual consistency", где система стремится обеспечить консистентность данных в течение некоторого времени. 
      Для этого часто используют шины сообщений и системы очередей, такие как Kafka или RabbitMQ, чтобы синхронизировать данные между сервисами.
</details>

---

Вопрос №5: [ Что такое сине-зеленый деплой (Blue-Green Deployment)? ]

<details>
  <summary>Ответ</summary>

    - Сине-зеленый деплой — это метод развертывания приложений, при котором создается полностью независимое окружение (зеленое), идентичное текущему
    продуктивному(синему). После проверки новой версии приложения в зеленом окружении, трафик переключается на это окружение, сделав его новым продуктивным. 
    Этот метод позволяет мгновенно откатываться к предыдущей версии, если что-то пошло не так, так как синее окружение остается нетронутым.
    
    Преимущества:
      - Быстрый откат: Если в новой версии есть проблемы, можно быстро вернуться к старой версии.
      - Нулевое время простоя: Переключение трафика происходит мгновенно, что исключает простои.
</details>

---

Вопрос №6: [ Что такое системы оркестрации контейнеров? ]

<details>
  <summary>Ответ</summary>

    - Системы оркестрации контейнеров, такие как Kubernetes, Docker Swarm или Mesos, используются для автоматизации развертывания, масштабирования 
      и управления контейнеризованными приложениями.

    Для чего они нужны:
      - Автоматизация развертывания: Один раз описав как должен работать ваш сервис, вы можете автоматически развернуть его на любом числе машин.
      - Масштабирование: Вам не нужно вручную добавлять или удалять контейнеры. Оркестратор может делать это автоматически, в зависимости от нагрузки.
      - Балансировка нагрузки: Оркестраторы могут автоматически распределять входящий трафик между контейнерами одного сервиса.
      - Высокая доступность: Оркестраторы могут перезапускать упавшие контейнеры и перемещать их между хостами.
      - Обновление и откат: Оркестраторы могут обновлять приложения с минимальными простоями, а также откатывать их до предыдущих версий.

    Эти возможности делают системы оркестрации ключевым компонентом для современных облачных и микросервисных архитектур.
</details>

---

Вопрос №7: [ Что такое рефлексия? ]

<details>
  <summary>Ответ</summary>

    - Рефлексия в программировании — это механизм, который позволяет программам исследовать информацию о типах и структурах данных во время выполнения. 
      В Go рефлексия основана на двух ключевых типах: Type и Value, которые определены в пакете reflect.
      
    С помощью рефлексии можно:
      - Определять тип переменной во время выполнения.
      - Исследовать структуры и их поля, интерфейсы, значения массивов и множество других аспектов данных.
      - Создавать новые значения, изменять их и вызывать методы на них динамически.

    Зачем это нужно?
    Рефлексия часто используется в ситуациях, где типы данных неизвестны до времени выполнения. Например, она полезна при работе с библиотеками для маршалинга
    и анмаршалинга данных (например, JSON, XML), создании ORM, фреймворков для тестирования и многом другом.

    Осторожно!!!
    Несмотря на свою мощь, рефлексию следует использовать осторожно:
      - Производительность: Рефлексивные операции обычно медленнее, чем их нерефлексивные аналоги.
      - Читаемость кода: Рефлексия может сделать код сложнее для понимания и поддержки.
      - Типобезопасность: Рефлексия может привести к ошибкам во время выполнения из-за неправильного использования типов или несуществующих полей/методов.

    Таким образом, рефлексия — мощный, но "острый" инструмент, и его следует использовать разумно.
</details>

---

Вопрос №8: [ Что такое асинхронность? ]

<details>
  <summary>Ответ</summary>

    - Вычисления в системе могут идти двумя способами:
        - синхронно - это когда код выполняется последовательно;
        - асинхронно - это когда операцию мы можем выполнять не дожидаясь результата на месте. Обычно подразумевается, что операция может быть выполнена кем-то на стороне.
</details>

---

Вопрос №9: [ Что такое параллельность? ]

<details>
  <summary>Ответ</summary>

    - Вычисления будут являться параллельным только в том случае, если они выполняются одновременно. 
      Как пример можно привести процесс ремонта в доме. У нас есть несколько мастеров-универсалов, 
      каждый из которых выполняет работы на своем объекте под ключ. При этом производительность мастеров не зависит друг от друга, 
      так как их работа не пересекается.
</details>

---

Вопрос №10: [ Что такое конкурентность? ]

<details>
  <summary>Ответ</summary>

    - Конкурентность обеспечивает выполнение нескольких задач посредством переключения контекста. 
      Конкурентные вычисления реализуются на одном ядре системы. Как пример приведем тот же процесс ремонта, но с другими вводными условиями. 
      Теперь мы имеем один объект, на который привлекаем специалистов разного профиля: по демонтажным работам, электрике, подготовке стен и полов, отделке. 
      При этом у нас часто возникают ситуации, когда хозяин уже в процессе подготовки стен, решает, что вот эта стена ему все же не нужна, и на сцену опять выходят демонтажники. 
      Такой процесс организации работ можно назвать конкурентным, так как наши мастера уступают место друг другу, одновременно клеить обои и ломать стены они не могут.
</details>

---

</details>

<!-- Сеть и всё что с ней связано -->
<details>
    <summary><h2><i>Сеть и всё что с ней связано</i></h2></summary>

---

Вопрос №1: [ В чем отличие протоколов TCP и UDP? ]

<details>
   <summary>Ответ</summary>

    - TCP (Transmission Control Protocol)
        - Ориентирован на установление надежного соединения.
        - Ошибки корректируются; потерянные или поврежденные пакеты пересылаются.
        - Поддерживает управление потоком и перегрузкой.
        - Нормально работает в условиях высокой задержки.

    - UDP (User Datagram Protocol)
        - Безусловный протокол, не устанавливает соединение.
        - Ошибки не корректируются; потерянные пакеты не восстанавливаются.
        - Не поддерживает управление потоком и перегрузкой.
        - Обычно быстрее, чем TCP.

    - Когда UDP предпочтительнее:
        - Потоковое медиа, онлайн-игры, VoIP — там, где задержка критична и потеря пакетов допустима.
</details>

---

Вопрос №2: [ Какие еще протоколы существуют? ]

<details>
  <summary>Ответ</summary>

    - Транспортный уровень (как TCP и UDP):
        - SCTP (Stream Control Transmission Protocol) — протокол, предназначенный для передачи данных с поддержкой множественных потоков и устойчивый к ошибкам.
        - CCP (Datagram Congestion Control Protocol) — протокол, предназначенный для передачи потоковых медиа.

    - Сетевой уровень:
        - IP (Internet Protocol) — протокол маршрутизации.
        - ICMP (Internet Control Message Protocol) — протокол управляющих сообщений.
        - OSPF (Open Shortest Path First) — протокол динамической маршрутизации.

    - Канальный уровень:
        - Ethernet — наиболее распространенный протокол канального уровня.
        - Wi-Fi — набор стандартов для беспроводных локальных сетей.

    - Прикладной уровень:
        - HTTP/HTTPS (HyperText Transfer Protocol/Secure) — протокол передачи гипертекста.
        - FTP (File Transfer Protocol) — протокол передачи файлов.
        - SMTP (Simple Mail Transfer Protocol) — протокол для передачи электронной почты.
        - DNS (Domain Name System) — система преобразования доменных имен в IP-адреса.
        - MQTT (Message Queuing Telemetry Transport) — протокол мессенджинга для IoT устройств.
        - Это далеко не исчерпывающий список, и существует множество других протоколов для различных специфических задач и сценариев использования.

</details>

---

</details>

<!-- Операционная система -->
<details>
    <summary><h2><i>Операционная система</i></h2></summary>

---

Вопрос №1: [ Можно ли убить поток внутри определенного процесса командой kill? ]

<details>
  <summary>Ответ</summary>

    - Обычно команда kill убивает процессы, а не отдельные потоки. В Linux потоки являются частью процесса и не могут быть убиты независимо от него командой kill.
</details>

---

</details>

<!-- Базы данных -->
<details>
    <summary><h2><i>Базы данных</i></h2></summary>

---

Вопрос №1: [ Какая разница между реляционными vs не реляционными СУБД? ]

<details>
  <summary>Ответ</summary>

    - SQL:
        Плюсы:
          - Строгая схема: Помогает в поддержании целостности данных.
          - ACID-свойства: Поддержка транзакций с гарантированной Атомарностью, Согласованностью, Изолированностью и Долговечностью.
          - SQL: Богатый язык запросов, хорошо подходящий для сложных запросов.
          - Широкая поддержка: Огромное сообщество, много документации и инструментов.
          - Зрелость: Проверенные временем, надежные решения.
        Минусы:
          - Горизонтальное масштабирование: Обычно сложнее масштабировать горизонтально по сравнению с NoSQL.
          - Сложность: SQL и реляционные схемы могут быть сложными для новичков.
          - Стоимость: Коммерческие решения могут быть дорогими.

    - NoSQL:
        Плюсы:
          - Масштабируемость: Обычно проще масштабировать горизонтально.
          - Гибкость схемы: Можно легко добавлять поля в данные.
          - Высокая производительность: Оптимизированы для больших данных и реального времени.
          - Разнообразие моделей данных: ключ-значение, документ-ориентированные, колоночные и графовые базы данных.
        Минусы:
          - Недостаток стандартизации: Множество разных систем с разными API.
          - Сложность: Распределенные системы приносят собой сложности в управлении и обслуживании.
          - Недостаточная поддержка транзакций: Не все NoSQL-системы поддерживают ACID-транзакции.
        
    - Когда выбрать NoSQL?
        - При необходимости горизонтального масштабирования.
        - Когда схема данных непостоянна или развивается со временем.
        - Для больших данных и обработки в реальном времени.

    - Какие NoSQL решения знаешь?
        - MongoDB, Cassandra, Redis, и Couchbase.
        
    - Трудности при работе с NoSQL:
        - Сложность управления распределенной системой.
        - Отсутствие стандартизированного языка запросов, как SQL.
        - Вопросы консистентности данных, особенно в распределенных системах.
</details>

---

</details>

<!-- Golang -->
<details>
    <summary><h2><i>Golang</i></h2></summary>

<!-- Общие вопросы по языку Go -->
- <details>
    <summary><h3><i>Общие вопросы по языку Go</i></h3></summary>

  ---

  - Вопрос №1: [ Расскажи кратко о языке Go ]

    <details>
      <summary>Ответ</summary>

        - Go (Golang) — это компилируемый многопоточный язык программирования от Google с открытым исходным кодом. 
          Считается языком общего назначения, но основное применение — разработка веб-сервисов и клиент-серверных приложений.
        - Язык Go был представлен в 2009 году в корпорации Google. Его полное название — Golang — производное от «Google language». 
          Язык создали Роб Пайк и Кен Томпсон.
        - У языка: Строгая статическая типизация, понятный и простой синтаксис, встроеный «сборщика мусора»  
    </details>

  ---

  - Вопрос №2: [ Как реализовано хранилище памяти в Go? ]

    <details>
      <summary>Ответ</summary>

        - Хранилища памяти в Go реализованы с помощью двух подходов:
        - хранение в stack. в основном используется для хранения локальных переменных, аргументов функции. 
          Из плюсов -stack достаточно легко очищается. 
          Из минусов - при аллокациях на stack существуют копии одних и тех же значений, которые надо хранить и обрабатывать.
        - хранение в heap. в основном используется для хранения глобальный переменных и ссылочных типов. 
          Из плюсов - при аллокациях на heap существует всегда одно уникальное значение, которое надо хранить и обрабатывать. 
          Из минусов - heap тяжело очищается, так как приходится запускать сборщик мусора, который имеет много накладных расходов и останавливает приложение.
    </details>

  ---

  - Вопрос №3: [ Какие типы данных есть в языке Go? ]

    <details>
      <summary>Ответ</summary>

        - Boolean: bool (значения true или false)

        - Целочисленные типы:
          int и uint: знаковые и беззнаковые целые числа, размер зависит от платформы (32 или 64 бита)
          int8, int16, int32, int64: знаковые целые числа с фиксированным размером
          uint8, uint16, uint32, uint64: беззнаковые целые числа с фиксированным размером
          uintptr: беззнаковый целочисленный тип, достаточный для хранения разыменованного указателя

        - Числа с плавающей точкой:
          float32, float64: числа с плавающей точкой

        - Комплексные числа:
          complex64, complex128: комплексные числа

        - Строки и символы:
          Строки: string
          Байты: byte (эквивалент типа uint8)

        - Составные типы:
          Массивы: например, [5]int (массив из 5 целых чисел)
          Срезы: например, []int (динамически изменяемый массив)
          Map (ассоциативный массив): например, map[string]int
          Структуры: например, struct { Name string; Age int }

        - Другие типы:
          Интерфейсы: interface{}
          Каналы: chan
          Указатели: например, *int (указатель на целое число)

    </details>

  ---

  - Вопрос №4: [ Что такое пакеты в go? ]

    <details>
      <summary>Ответ</summary>

        - Пакет - это механизм переиспользования кода, при котором go файлы помещаются в общую директорию. 
          В начале каждого такого файла объявляется зарезервированное слово package, а после него прописывается имя пакета. 
          В рамках пакета все функции и глобальные переменные, объявленные как в верхнем, так и в нижнем регистре, видят друг друга.   
    </details>

  ---

  - Вопрос №5: [ Что такое глобальная переменная? ]

    <details>
      <summary>Ответ</summary>

        - Глобальная переменная - это переменная уровня пакета, то есть объявленная вне функции. 
          Глобальная переменная также может быть доступна за рамками пакета, конечно только в том случае, если ее наименование начинается в верхнем регистре.
    </details>

  ---

  - Вопрос №6: [ Что такое константы и можно ли их изменять? ]

    <details>
      <summary>Ответ</summary>

        - Константы - это неизменяемые переменные, изменить константу нельзя.
    </details>

  ---

  - Вопрос №7: [ Зачем фигурные скобки с не объявленным оператором внутри функции? ]

    <details>
      <summary>Ответ</summary>

        - В go функции действительно можно объявить {} без оператора, ограничив область видимости куска кода в рамках этой функции.
    </details>

  ---

  - Вопрос №8: [ В go есть оператор switch case, можно ли выполнить несколько условий в одном объявленном операторе? ]

    <details>
      <summary>Ответ</summary>

        - Такое возможно благодаря ключевому слову fallthrough. Оно заставляет выполнять код в следующей объявленной 
          булевой секции, вне зависимости подходит ли булевое условие case этой секции.

    </details>

  ---

  - Вопрос №9: [ Что такое iota? ]

    <details>
      <summary>Ответ</summary>

        - iota - это идентификатор, который позволяет создавать последовательные не типизированные целочисленные константы. 
          Значением iota является индекс ConstSpec. Не смотря на то, что первым индексом является 0, значение первой 
          константы можно задать отличным от 0, что в свою очередь повлияет на значения последующих констант.

    </details>

  ---

  - Вопрос №10: [ Как вручную задать количество процессоров для приложения? ]

    <details>
      <summary>Ответ</summary>

        - Это позволяет сделать runtime.GOMAXPROCS(). Важно понимать, что при выставлении количества логических 
          процессоров больше, чем есть у вас в системе, вы рискуете получить определенные проблемы с производительностью. 
          Чтобы избежать этого можно задать runtime.GOMAXPROCS(runtime.NumCPU()), runtime.NumCPU() - количество логических процессоров.
    </details>

  ---

  - Вопрос №11: [ Как принудительно переключить контекст? ]

    <details>
      <summary>Ответ</summary>

        - Переключение контекста вручную осуществляется с помощью функции runtime.Goshed().
    </details>

  ---

  - Вопрос №12: [ Что такое graceful shutdown? ]

    <details>
      <summary>Ответ</summary>

        - У каждого сервера есть потребность в его отключении, обычно это происходит при получении сигнала от ОС. 
          И хорошо бы делать это отключение корректно, останавливая поэтапно все службы. Согласитесь никто из нас не 
          выключает телевизор ударом табурета по корпусу. Так же и с сервером, для корректного отключения которого есть 
          общие подходы. К примеру:
        - создать канал, прослушивающий системные сигналы на выход;
        - прослушивать этот канал;
        - при получении сигнала поэтапно выходить из горутин;
        - остановить сервер.
    </details>

  ---

  - Вопрос №13: [ Что обозначает * и &? ]

    <details>
      <summary>Ответ</summary>

        - "&" - это адрес блока памяти. То есть &myVar - это адрес того места в памяти, где хранятся данные переменной myVar. Тогда как "*" можно использовать в двух вариантах:
          чтобы объявить тип-указатель var pointVar *int. В данном случае указатель на int;
          чтобы получить значение по адресу *pointVar. Обратный предыдущему процесс, и здесь мы получим значение по адресу pointVar.
    </details>

  ---

  - Вопрос №14: [ Как происходит передача параметров в функцию? ]

    <details>
      <summary>Ответ</summary>

        - Параметры в Go всегда передаются по значению. Это значит, что всякий раз, когда мы передаем аргумент в функцию, 
          функция получает копию первоначального значения. Чтобы работать именно с той же самой переменной, не копируя ее, 
          необходимо использовать адрес этой переменной. При этом сам указатель будет скопирован.
    </details>

  ---

  - Вопрос №15: [ Есть ли особенности поведения при передаче map и slice в функцию? ]

    <details>
      <summary>Ответ</summary>

        - Передача slice и map может заставить усомниться в том, что они передаются в функцию по значению. Однако здесь 
          так же происходит копирование. Структуры slice и map (уточнение: в случае map копируется не сама структура, 
          а указатель на структуру hmap, подробнее о том, что такое hmap можно прочитать в документации) копируются, 
          однако в самих структурах содержатся ссылки на области памяти, благодаря которым создается эффект передачи по ссылке.
    </details>

  ---

  - Вопрос №16: [ Как функции делятся памятью? ]

    <details>
      <summary>Ответ</summary>

        - В начале следует сказать про фрейм. Фрейм можно представить как отдельное пространство памяти для конкретной функции. 
          Функция может работать с памятью в своем фрейме, однако не может работать с памятью фреймов других функций. 
          Когда из одной функции мы вызываем другую функцию, происходит переход фреймов. Чтобы использовать какие-то 
          данные предыдущего фрейма в следующем их можно передать по значению. Если необходимо работать не с копией, 
          а именно переменной другого фрейма, необходимо использовать переменные-указатели, которые обеспечивают доступ 
          до переменных других фреймов.
    </details>

  ---

  </details>

<!-- Численные типы -->
- <details>
    <summary><h3><i>Численные типы</i></h3></summary>

  ---

  - Вопрос №1: [ Какие численные типы есть? ]

    <details>
      <summary>Ответ</summary>

        - Целочисленные типы:
          int8: 8-битное знаковое целое число (-128 до 127)
          int16: 16-битное знаковое целое число (-32,768 до 32,767)
          int32 (rune): 32-битное знаковое целое число (-2,147,483,648 до 2,147,483,647)
          int64: 64-битное знаковое целое число (-9,223,372,036,854,775,808 до 9,223,372,036,854,775,807)
          uint8 (byte): 8-битное беззнаковое целое число (0 до 255)
          uint16: 16-битное беззнаковое целое число (0 до 65,535)
          uint32: 32-битное беззнаковое целое число (0 до 4,294,967,295)
          uint64: 64-битное беззнаковое целое число (0 до 18,446,744,073,709,551,615)
          int: знаковое целое число, размер зависит от платформы (обычно 32 или 64 бита)
          uint: беззнаковое целое число, размер зависит от платформы (обычно 32 или 64 бита)
          uintptr: беззнаковое целое число, достаточное для хранения разыменованного указателя (размер зависит от платформы)

        - Числа с плавающей точкой:
          float32: 32-битное число с плавающей точкой (приблизительный диапазон от 1.4E-45 до 3.4E+38)
          float64: 64-битное число с плавающей точкой (приблизительный диапазон от 4.9E-324 до 1.8E+308)

        - Комплексные числа:
          complex64: комплексное число с двумя 32-битными числами с плавающей точкой (для действительной и мнимой частей)
          complex128: комплексное число с двумя 64-битными числами с плавающей точкой (для действительной и мнимой частей)

    </details>

  ---

  - Вопрос №2: [ Какой результат получим если разделить int на 0 и float на 0? ]

    <details>
      <summary>Ответ</summary>

        - Это вопрос с подвохом. Деление int на 0 в go невозможно и вызовет ошибку компилятора.
          Тогда как деление float на 0 дает в своем результате бесконечность.
    </details>

  ---

  </details>

<!-- Строки -->
- <details>
    <summary><h3><i>Строки</i></h3></summary>

  ---

  - Вопрос №1: [ Что представляют собой строки в go? ]

    <details>
      <summary>Ответ</summary>

        - Строки в go - это обычный массив байт. Это надо понимать для того, чтобы ответить на следующие вопросы о строках.
        - Как можно оперировать строками?
          Строки в go можно складывать(конкатенировать), сравнивать, получить срез, длинну, и т.д

        - Что будет если сложить строки?
          Мы будем получать новые строки

        - Как определить количество символов для строки?" или "Какие есть нюансы при итерации по строке?
          Исходя из того же знания, что строка это массив байт, взяв базовую функцию len() от строки мы получим количество байт. 
          Похожее поведение будет при итерации по строке - итерация по байтам. Тогда как в зависимости от кодировки, 
          символ в строке может занимать не один байт. Для того, чтобы работать именно с символами, необходимо преобразовать 
          строку в тип []rune. Еще одним способом определения длинны строки является функция RuneCountInString пакета utf8.
    </details>

  ---

  - Вопрос №2: [ Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно? ]

    <details>
      <summary>Ответ</summary>

        - Преобразование типов между int и string указанным синтаксисом невозможно. Для преобразования необходимо 
          использовать функции из пакета strconv стандартной библиотеки go. При этом для преобразования строк 
          в/из int и int64 используются разные функции, strconv.Atoi и strconv.Itoa для int, 
          strconv.ParseInt и strconv.FormatInt соответственно.
    </details>

  ---

  </details>

<!-- Интерфейсы -->
- <details>
    <summary><h3><i>Интерфейсы</i></h3></summary>

  ---

  - Вопрос №1: [ Интерфейсы: Что такое интерфейс в Go? Зачем нужен на практике? Примеры задач где стоит ввести? ]

    <details>
      <summary>Ответ</summary>

        - В Go, интерфейс — это набор сигнатур методов (контракт). Тип, реализующий все методы, указанные в интерфейсе, считается 
          реализующим этот интерфейс. Особенностью языка Go является неявная реализация интерфейсов: вам не нужно явно
          указывать, что тип реализует интерфейс.

        - Зачем нужны интерфейсы на практике:
          Абстракция: Интерфейсы позволяют абстрагировать поведение, делая код более модульным и легко тестируемым.
          Расширяемость: Легко добавлять новые функциональности, не меняя существующий код.
          Полиморфизм: Работа с разными типами данных, как если бы они были одним и тем же типом.

        - Примеры задач, где стоит ввести интерфейс
          Логирование: Если у вас есть несколько способов логирования (в файл, в БД, через сеть), вы можете определить 
          интерфейс Logger с методом Log, и затем реализовать его различными способами.
          Сетевые запросы: Если ваше приложение взаимодействует с различными внешними API, вы можете создать интерфейс 
          APIClient с методами, которые нужны для взаимодействия с API.
          Тестирование: Интерфейсы позволяют легко мокать зависимости, что упрощает тестирование.

    </details>

  ---

  - Вопрос №2: [ Что такое пустой интерфейс? ]

    <details>
      <summary>Ответ</summary>

        - В Go, пустой интерфейс interface{} не имеет методов. Это означает, что любой тип автоматически реализует 
          пустой интерфейс, и вы можете присвоить значение любого типа переменной пустого интерфейса. Это обычно 
          используется для создания контейнеров, которые могут хранить значения любого типа, или для функций, 
          которые могут принимать аргументы любого типа.
    </details>

  ---

  - Вопрос №3: [ Как устроен внутри nil интерфейс vs nil внутри интерфейса? ]

    <details>
      <summary>Ответ</summary>

        - Под капотом, интерфейс в Go — это двухсловная структура, содержащая:
          Type: Указатель на информацию о типе. Это позволяет интерфейсу знать, какой именно тип он хранит.
          Data: Указатель на само значение.
          Для пустого интерфейса эта структура особенно полезна, потому что Type будет указывать на реальный тип данных, 
          хранящихся в Data, что позволяет динамически определять тип при выполнении (runtime).
          Этот механизм делает интерфейсы относительно медленными по сравнению с конкретными типами, так как добавляет 
          дополнительный уровень индирекции и необходимость динамического определения типов. Однако это не всегда критично 
          и является приемлемой "ценой" за удобство и гибкость интерфейсов.
          Таким образом, использование пустого интерфейса в Go — это удобный, но не всегда оптимальный с точки зрения 
          производительности способ работы с данными неизвестного или переменного типа.

          ```var a interface{} 
             var b *int 
             a=b 
             fmt.Println("ab", a==nil)```
          
          - Nil интерфейс
            Когда мы говорим, что интерфейс равен nil, это означает, что оба поля внутренней структуры интерфейса 
            (Type и Data) равны nil. Это можно представить как "абсолютный" nil для интерфейса.

          ```var a interface{}
             fmt.Println(a == nil)  // Вывод: true```

          - Nil внутри интерфейса
            Пример var b *int создает указатель на int, который равен nil. Однако, когда этот nil указатель присваивается 
            интерфейсной переменной a, поле Type внутренней структуры интерфейса теперь указывает на тип *int, 
            в то время как поле Data равно nil.

          ```var a interface{}
             var b *int
             a = b
             fmt.Println(a == nil)  // Вывод: false```

          - Здесь a == nil вернет false, потому что, хотя Data равно nil, Type указывает на тип *int. С точки зрения интерфейса, это не nil.
            Этот аспект может иногда приводить к неожиданному поведению и ошибкам, и его важно понимать при работе с интерфейсами в Go. 
    </details>

  ---

  - Вопрос №4: [ Как определить тип интерфейса? ]

    <details>
      <summary>Ответ</summary>

        - С помощью инструкции switch case и приведения типа можно определить тип интерфейса, указав возможные варианты 
          базового типа его значения.

        ```switch v := animal.(type) {
           case Dog:
           fmt.Println("It's a dog:", v.Speak())
           default:
           fmt.Println("Unknown type")
           }```
    </details>

  ---

  - Вопрос №5: [ В каком пакете лучше объявлять интерфейсы и почему? ]

    <details>
      <summary>Ответ</summary>

        - В Go интерфейсы часто объявляются в том пакете, который будет использовать, а не реализовывать, этот интерфейс. 
          Это принципиально отличается от некоторых других языков программирования, где интерфейсы часто объявляются 
          в том же пакете, что и их реализации. Рассмотрим причины этого:

          Цель интерфейса
          Интерфейс в Go — это определение "контракта": он описывает, что должен делать тип, но не как. Клиентский код, 
          который опирается на этот "контракт", важнее, чем реализации, потому что интерфейс обеспечивает абстракцию, 
          которая позволяет клиентскому коду не зависеть от конкретных реализаций.

          Разделение зависимостей
          Если вы помещаете интерфейс в пакет, который будет его использовать, то этот пакет не становится зависимым от 
          всех пакетов, которые реализуют этот интерфейс. Это упрощает управление зависимостями.

          Принцип наименьшего знания
          Пакеты, реализующие интерфейс, не должны знать о существовании интерфейса. Это уменьшает связность кода и 
          делает его более модульным и легким для тестирования и переиспользования.

          В целом, нет строгих правил, где должны объявляться интерфейсы, и иногда имеет смысл объявлять их в пакете с 
          реализацией, особенно если интерфейс и его реализация очень тесно связаны. Однако часто более полезным оказывается 
          принцип "интерфейсы в пакете-пользователе, реализации где-то еще".
    </details>

  ---

  </details>

<!-- Массивы и слайсы -->
- <details>
    <summary><h3><i>Массивы и слайсы</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое слайс и чем он отличается от массива? ]

    <details>
      <summary>Ответ</summary>

        - Cлайс - это структура go, которая включает в себя ссылку на базовый массив, а также две переменные len(length) и cap(capacity).
          len это длина слайса - то количество элементов, которое в нём сейчас находится.
          cap - это ёмкость слайса - то количество элементов, которые мы можем записать в слайс сверх len без его дальнейшего расширения.
          Array - это последовательно выделенная область памяти. Частью типа array является его размер, который в том числе является не изменяемым.
    </details>

  ---

  - Вопрос №2: [ Какой размер массива выделяется под слайс при его расширении за рамки его емкости? ]

    <details>
      <summary>Ответ</summary>

        - Если отвечать на вопрос поверхностно, то можно сказать, что базовый массив расширяется в два раза от нашей capacity.
        Отвечая более емко, следует учесть, что при больших значениях расширение будет не в два раза и будет вычисляться по 
        специальной формуле в функции growslice().

        Если развернуть ответ полностью, то это будет звучать примерно так: 
        * если требуемая cap больше чем вдвое исходной cap, то новая cap будет равна требуемой;
        * если это условие не выполнено, а также len текущего слайса меньше 256, то новая cap будет в два раза больше базовой cap;
        * если первое и второе условия не выполнены, то емкость будет увеличиваться в цикле на четверть от базовой емкости пока 
        не будет обработано переполнение. Посмотреть эти условия более подробно можно в исходниках go.
    </details>

      ---

      </details>

<!-- Map -->
- <details>
    <summary><h3><i>Map</i></h3></summary>

  ---

  - Вопрос №1: [ Как реализована map(карта) go? ]

    <details>
      <summary>Ответ</summary>

        - Сама map в go - это структура, реализующая операции хеширования. При этом, так же как и любую структуру, 
          содержащую ссылки на области памяти,map необходимо инициализировать. map ссылается на такие элементы как 
          bucket (в переводе на русский "ведра"). Каждый bucket содержит в себе:

        * 8 экстра бит, с помощью которых осуществляется доступ до значений в этом bucket;
        * ссылку на следующий коллизионный bucket;
        * 8 пар ключ-значение, уложенных в массив.
    </details>

  ---

  - Вопрос №2: [ Можно ли брать ссылку на значение, хранящееся по ключу в map? ]

    <details>
      <summary>Ответ</summary>

        - Нельзя так как map поддерживает процедуру эвакуации. Значения, хранящиеся в определённой ячейки памяти в текущий момент 
          времени, в следующий момент времени уже могут там не храниться.
    </details>

  ---

  - Вопрос №3: [ Что такое эвакуация, и в каком случае она будет происходить? ]

    <details>
      <summary>Ответ</summary>

        - Эвакуация - это процесс когда map переносит свои значения из одной области памяти в другую. Это происходит 
          из-за того что число значений в каждом отдельном bucket максимально равно 8.
          В тот момент времени, когда среднее количество значений в bucket составляет 6.5, go понимает, что размер map 
          не удовлетворяет необходимому. Начинается процесс расширения map.
          Следует отметить, что сам процесс эвакуации может происходить некоторое время, на протяжение которого новые и 
          старые данные будут связаны.
    </details>

  ---

  - Вопрос №4: [ Какие есть особенности синтаксиса получения и записи значений в map? ]

    <details>
      <summary>Ответ</summary>

        - Получить значение из map, которую мы предварительно не аллоцировали нельзя, приложение упадет в панику.
          Если ключ не найден в map в ответ мы получим дефолтное значение для типа значений map. То есть, 
          для строки - это будет пустая строка, для int - 0 и так далее. Для того, чтобы точно понять, что в map 
          действительно есть значение, хранящееся по переданному ключу, необходимо использовать специальный синтаксис. 
          А именно, возвращать не только само значение, но и булевую переменную, которая показывает удалось-ли получить 
          значение по ключу.
    </details>

  ---

  - Вопрос №5: [ Как происходит поиск по ключу в map? ]

    <details>
      <summary>Ответ</summary>

        - вычисляется хэш от ключа;
        - с помощью значения хэша и размера bucket вычисляется используемый для хранения bucket;
        - вычисляется дополнительный хэш - это первые 8 бит уже полученного хэша;
        - в полученном bucketпоследовательно сравнивается каждый из 8 его дополнительных хэшей с дополнительным хэшем ключа;
        - если дополнительные хэши совпали, то получаем ссылку на значение и возвращаем его;
        - если дополнительные хэши не совпали, и в bucket больше нет дополнительных хэшей, алгоритм переходит в 
          следующий bucket, ссылка на который хранится в текущем;
        - если в текущем bucket нет ссылки на следующий bucket, а значение так и не найдено, возвращается дефолтное значение.

    </details>

  ---

  </details>

<!-- Defer -->
- <details>
    <summary><h3><i>Defer</i></h3></summary>

  ---

  - Вопрос №1: [ Зачем используется ключевое слово defer в go? ]

    <details>
      <summary>Ответ</summary>

        - Ключевое слово defer используется для отложенного вызова функции. При этом, место объявления одной инструкции 
          defer в коде никак не влияет на то, когда та выполнится.
          Функция с defer всегда выполняется перед выходом из внешней функции, в которой defer объявлялась.
    </details>

  ---

  - Вопрос №2: [ Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции? ]

    <details>
      <summary>Ответ</summary>

        - defer добавляет переданную после него функцию в стэк. При возврате внешней функции, вызываются все, добавленные 
          в стэк вызовы. Поскольку стэк работает по принципу LIFO (last in first out), значения стэка возвращаются в 
          порядке от последнего к первому.
          Таким образом функции c defer будут вызываться в обратной последовательности от их объявления во внешней 
          функции.
    </details>

  ---

  - Вопрос №3: [ Как передаются значения в функции, перед которыми указано ключевое слово defer? ]

    <details>
      <summary>Ответ</summary>

        - Аргументы функций, перед которыми указано ключевое слово defer оцениваются немедленно. То есть на тот момент, 
          когда переданы в функцию.
    </details>

  ---

  </details>

<!-- Горутины -->
- <details>
    <summary><h3><i>Горутины</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое поток и горутина? ]

    <details>
      <summary>Ответ</summary>

        - Поток (Thread)
          Поток — это базовая единица выполнения кода в операционной системе. Каждый поток имеет свой собственный стек и
          счетчик команд, но потоки из одного и того же процесса обычно разделяют ту же область памяти (кучу), переменные
          окружения и открытые файлы. Современные операционные системы, такие как Windows, macOS и Linux, поддерживают
          многопоточные процессы.

          Преимущества:
          Потоки в одном процессе могут легко разделять ресурсы, такие как память и переменные.
          Создание нового потока обычно менее ресурсоемко, чем создание нового процесса.

          Недостатки:
          Управление потоками и синхронизация между ними могут быть сложными.
          Проблемы, такие как "гонка" (race conditions), могут возникнуть, если необходимая синхронизация между потоками 
          не реализована правильно.

        - Горутины — это абстракция, предоставляемая языком программирования Go, для создания легковесных потоков выполнения. 
          Горутины работают на фоне операционных потоков, но управляются Go runtime, что делает их более легковесными и 
          эффективными для многозадачности.

          Преимущества:
          Легковесны и требуют меньше памяти по сравнению с обычными потоками.
          Go runtime автоматически обрабатывает все детали, связанные с жизненным циклом горутин, включая планирование и синхронизацию.

          Недостатки:
          Специфичны для языка Go и не могут быть использованы в других языках программирования без подобной абстракции.

        - Процессы, потоки и горутины представляют разные уровни абстракции для выполнения кода в операционных системах 
          и языках программирования. Рассмотрим их отличия:

          Процесс
          Изоляция: Процесс является полностью изолированной единицей выполнения с собственным адресным пространством и ресурсами.
          ОС: Управляется напрямую операционной системой.
          Затраты: Создание, уничтожение и контекстное переключение процессов являются дорогостоящими операциями.
          Коммуникация: Взаимодействие между процессами (IPC, Inter-Process Communication) обычно медленное и сложно настраивается.
          Примеры: Веб-сервер, база данных, браузер — каждый из них является отдельным процессом.

          Поток (Thread)
          Изоляция: Потоки внутри одного процесса разделяют адресное пространство и ресурсы, что упрощает коммуникацию между ними.
          ОС: Также управляется операционной системой, но легче и быстрее создавать и уничтожать по сравнению с процессами.
          Затраты: Меньше ресурсов требуется для создания, уничтожения и переключения контекста.
          Коммуникация: Быстрое взаимодействие между потоками за счет общего адресного пространства.
          Примеры: Потоки внутри веб-сервера, которые обрабатывают отдельные входящие соединения.

          Горутина (Goroutine)
          Изоляция: Горутины являются ещё более "легковесными" потоками, управляемыми средой исполнения Go, а не ОС.
          ОС: Управляется планировщиком в среде исполнения Go.
          Затраты: Очень дешевы в плане ресурсов. Создание, уничтожение и переключение контекста выполняются очень быстро.
          Коммуникация: Используют каналы и другие средства синхронизации Go для взаимодействия, что делает код более читаемым и поддерживаемым.
          Примеры: Отдельные задачи внутри веб-сервера на Go, работающие параллельно для обработки входящих запросов.

          В итоге, выбор между этими требуется сделать на основе нужд в изоляции, уровне управления и ресурсах. 
          Горутины предоставляют высокоуровневую абстракцию с минимальными затратами, потоки предоставляют более гибкий 
          контроль при меньших затратах по сравнению с процессами, а процессы предоставляют полную изоляцию и управляются 
          напрямую операционной системой.
    </details>

  ---

  - Вопрос №2: [ Сколько можно запустить потоков и горутин? ]

    <details>
      <summary>Ответ</summary>

        - Потоки: Ограничено ресурсами системы, обычно несколько тысяч.
        - Горутины: Теоретически, десятки и сотни тысяч, зависит от ресурсов и конкретной задачи.
    </details>

  ---

  - Вопрос №3: [ Каков минимальный и максимальный вес горутин? ]

    <details>
      <summary>Ответ</summary>

        - На этот вопрос, ожидается ответ, не сколько весят все вместе взятые поля в структуре g объекта горутины. 
          Интервьюера интересуют минимальный и максимальный размер стэка горутины. Минимальный (начальный) размер стэка 
          составляет 2 КБ. Максимальный размер стэка горутины зависит от архитектуры системы и равен 1 ГБ для 64-разрядной 
          архитектуры, 250 МБ для 32-разрядной архитектуры.
    </details>

  ---

  - Вопрос №4: [ Что будет если размер горутины превысил допустимый максимум? ]

    <details>
      <summary>Ответ</summary>

        - Если размер стэка горутины превышен (к примеру запустили бесконечную рекурсию), то приложение упадет с fatal error.
    </details>

  ---

  - Вопрос №5: [ Какие есть способы остановить все горутины в приложении? ]

    <details>
      <summary>Ответ</summary>

        - Если размышлять глобально, то таких способа 3:
        * завершение main функции и main горутины;
        * прослушивание всеми горутинами channel, при закрытии channel отправляется значение по умолчанию всем слушателям, при получении сигнала все горутины делают return;
        * завязать все горутины на переданный в них context.
    </details>

  ---

  - Вопрос №6: [ Как наладить связь между горутинами? ]

    <details>
      <summary>Ответ</summary>

        - Горутины общаются друг с другом посредством перегонки необходимых данных по channel. Именно о каналах идет речь 
          в знаменитом девизе Go: "Не общайтесь, делясь памятью; делитесь памятью, общаясь".
    </details>

  ---

  </details>

<!-- Примитивы синхронизации -->
- <details>
    <summary><h3><i>Примитивы синхронизации</i></h3></summary>

  ---

  - Вопрос №1: [ Какие есть примитивы синхронизации? Расскажи немного про каждый ]

    <details>
      <summary>Ответ</summary>

        - wait group:
          sync.WaitGroup используется для ожидания завершения группы горутин. Это полезно, когда вы хотите дождаться 
          завершения всех запущенных задач.

        - mutex:
          sync.Mutex и sync.RWMutex — это примитивы для обеспечения взаимоисключающего доступа к ресурсам. 
          Mutex используется для обеспечения эксклюзивного доступа к критической секции кода.

        - atomic:
          предоставляет функции для выполнения атомарных операций на базовых типах данных, таких как int32, int64, 
          uint32, uint64, uintptr, и указателях. Эти операции гарантируют, что изменение значения будет выполнено 
          без прерываний, что полезно при высококонкурентном доступе к переменной.

        - sync map:
          sync.Map — это конкурентная (thread-safe) реализация карты, которая может быть безопасно использована 
          несколькими горутинами без дополнительной блокировки. Обычные карты в Go не являются безопасными для использования 
          в нескольких горутинах. Если вы пытаетесь одновременно читать и модифицировать карту из разных горутин, 
          это может привести к неопределённому поведению. sync.Map решает эту проблему.

        - once:
          sync.Once предназначен для безопасного выполнения какой-либо операции только один раз, независимо от того, 
          сколько горутин пытаются её выполнить.

        - channel:
          Каналы в Go — это мощный примитив для синхронизации и передачи данных между горутинами. Они могут быть 
          использованы как очереди сообщений или как семафоры.
    </details>

  ---

  - Вопрос №2: [ Что такое channel под капотом? ]

    <details>
      <summary>Ответ</summary>

        - channel - это абстракция Go, которая помогает горутинам общаться друг с другом, передавая по channel значения. 
          Канал можно представить как трубу, в которую одни горутины кладут данные, а другие их вычитывают. Под капотом 
          channel представляет из себя 3 структуры (hchan, sudog, waitq). Наиболее интересной для нас является hchan, основные поля которой:

        - qcount - количество элементов в буфере;
        - dataqsiz - размерность буфера;
        - buf - указатель на буфер для элементов канала;
        - elemsize - размер элемента в канале;
        - closed - флаг, указывающий, закрыт канал или нет (1/0 соответственно);
        - elemtyp - тип элемента;
        - recvq - указатель на связанный список горутин, ожидающих чтения из канала;
        - sendq - указатель на связанный список горутин, ожидающих запись в канал;
        - lock - мьютекс для безопасного доступа к каналу. Когда мы создаем канал, мы присваеваем hchan elemtype и 
          elemsize и аллоцируем структуру hchan в Heap.
    </details>

  ---

  - Вопрос №3: [ Что такое буферизированный и не буферизированный channel? ]

    <details>
      <summary>Ответ</summary>

        - channel делятся на два типа по наличию/отсутствию буфера. Соответственно в первом случае поле dataqsiz будет
          равно размеру переданного буфера (3), а поле buf будет ссылкой на этот буфер. Во втором случае поле dataqsiz 
          будет равно 0, а поле buf будет nil. Отсюда возникает различное поведение этих типов channel при операциях с ними
    </details>

  ---

  - Вопрос №4: [ Какие действия можно произвести с каналом? ]

    <details>
      <summary>Ответ</summary>

        - С channel можно сделать 4 действия:
        - создать канал
        - записать что-то в канал
        - что-то вычитать из канала
        - закрыть канал
    </details>

  ---

  - Вопрос №5: [ Что будет если писать/читать в nil channel? ]

    <details>
      <summary>Ответ</summary>

        - Как мы смотрели ранее, канал - это структура, которую надо инициализировать. Если же мы этого не сделали и пишем в nil канал
          то произойдет deadlockиfatal error(при условии всех спящих горутин), так как в исходниках Go идет проверка на nil.
          Точно такое же поведение будет при чтении из nil канала
    </details>

  ---

  - Вопрос №6: [ Что будет если писать/читать в/из закрытый channel? ]

    <details>
      <summary>Ответ</summary>

        - Запись в закрытый канал приведет к панике. Опять же из-за проверки флага в исходниках. 
          При чтении из закрытого канала мы получим совсем другое поведение - значение из буфера, если оно есть, или 
          дефолтное значение типа данных канала если буфер канала пуст
    </details>

  ---

  - Вопрос №7: [ Как закрыть channel? Что с ним происходит? ]

    <details>
      <summary>Ответ</summary>

        - Для закрытия канала предусмотрена функция close. Если упрощенно (опускаем блокировки), то при закрытии канала происходят следующие действия:
        - проверка, что канал инициализирован и не является nil (panic - если это не так);
        - проверка, что канал не закрыт (panic - если это не так);
        - поле close hchan выставляется в 1 (true);
        - отправка всем ожидающим чтения default value типа данных в канале;
        - ожидающие записи получают panic. Интересный момент, что так как закрытие канала не блокирует чтение канала, 
          то данные из буфера канала можно вычитать и после его закрытия.
    </details>

  ---

  - Вопрос №8: [ Какие есть инструкции для чтения из channel? ]

    <details>
      <summary>Ответ</summary>

        - Из канала можно читать значения:
          присваивая их в переменную;
          прослушивая канал с помощью инструкции for range;
          прослушивая канал с помощью инструкции select case. Также следует обратить внимание, что чтение из закрытого 
          канала отдает дефолтное значение типа данных канала. Поэтому существует возможность проверить, что при чтении 
          получено значение из буфера. Для этого используется синтаксис со второй (bool) переменной val, ok := <- myChan.
    </details>

  ---

  - Вопрос №9: [ Что будет если писать/читать в/из буферизированный channel? ]

    <details>
      <summary>Ответ</summary>

        - Запись в буферизированный канал не является блокирующей операцией до тех пор, пока не заполнится буфер канала. 
          После операция вызовет блокировку. Чтение из буферизированного канала не является блокирующим, если буфер 
          канала не пуст. При пустом буфере канала чтение из него вызовет блокировку. Важный момент, что чтение из 
          буферизированного канала - жадная операция. Если начался процесс чтения данных из канала, то данные будут 
          читаться без блокировки до момента опустошения буфера.
    </details>

  ---

  - Вопрос №10: [ Что будет если писать/читать в/из не буферизированный channel? ]

    <details>
      <summary>Ответ</summary>

        - Небуферизированный канал - это тот же буферизированный канал, но с nil буфером. Соответственно принцип его 
          работы будет таким же. Чтение из пустого и запись в непустой небуферизированный канал являются блокирующими операциями.
    </details>

  ---

  </details>

<!-- Switch/Select/Case -->
- <details>
    <summary><h3><i>Switch/Select/Case</i></h3></summary>

  ---

  - Вопрос №1: [ Как сделать select неблокирующим? ]

    <details>
      <summary>Ответ</summary>

        - Есть возможность задать поведение для select по умолчанию, то есть для случаев, когда не выполняются case. 
          Для этого необходимо добавить инструкцию default. Таким образом, когда не срабатывает ни один из case будет 
          срабатывать кусок кода под инструкцией default.
    </details>

  ---

  - Вопрос №2: [ Какой порядок исполнения операций case в select? ]

    <details>
      <summary>Ответ</summary>

        - Первым выполнится тот case в select, который будет готов. При одновременной отправке данных в каналы, 
          прослушиваемые в select порядок операций не гарантирован.
    </details>

  ---

  </details>

<!-- Context -->
- <details>
    <summary><h3><i>Context</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое context в GO? ]

    <details>
      <summary>Ответ</summary>

        - По сути context - это некий сборник метаданных, который можно привязать к какому-нибудь процессу. 
          К примеру для HTTP вызова можно объявить context, записать туда куки и иную информацию о пользователе. 
          По окончанию вызова context можно отменить.
    </details>

  ---

  - Вопрос №2: [ Для чего применяется context? ]

    <details>
      <summary>Ответ</summary>

        - У context два основных применения:
        - для отмены выполнения либо по таймауту, либо по дедлайну. Тот же пример с HTTP запросами;
        - для передачи параметров. Правда злоупотребление этим плохо сказывается на явности кодовой базы. 
          Обязательные параметры передавать через context все же не стоит.
    </details>

  ---

  - Вопрос №3: [ Чем отличается context.Background от context.TODO? ]

    <details>
      <summary>Ответ</summary>

        - И context.Background() и context.TODO() это одно и то же. Разница лишь в том, что context.TODO() выставляется 
          в местах, где пока нет понимания, что необходимо использовать context.Background() и возможно его надо 
          заменить на дочерний контекст.

    </details>

  ---

  - Вопрос №4: [ Как передавать значения и вычитывать их из context? ]

    <details>
      <summary>Ответ</summary>

        - В пакете context существует функция context.WithValue(parent Context, key, val interface{}) Context, 
          которая от родительского контекста создает производный и добавляет в него по key значение. 
          Извлекая значение из context необходимо помнить, что на выход получаем интерфейс, который необходимо 
          правильно скастить.
    </details>

  ---

  - Вопрос №5: [ Каковы отличия context.WithCancel, context.WithDeadline, context.WithTimeout? ]

    <details>
      <summary>Ответ</summary>

        - context.WithCancel(parent Context) (ctx Context, cancel CancelFunc) создает контекст производный от родительского,
          также возвращает функцию отмены, с помощью которой этот контекст можно закрыть. Общепринятой практикой является 
          работать с функцией отмены там, где она получена, не передавая ее глубже.
        - context.WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc) создает контекст производный
          от родительского, также возвращает функцию отмены, с помощью которой этот контекст можно закрыть. Контекст 
          автоматически отменится в переданное, как входной параметр функции, время.
        - context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc) создает контекст
          производный от родительского, также возвращает функцию отмены, с помощью которой этот контекст можно закрыть. 
          Контекст автоматически отменится через интервал времени, переданный, как входной параметр функции.
    </details>

  ---

  - Вопрос №6: [ Как обрабатывать отмену context? ]

    <details>
      <summary>Ответ</summary>

        - Отмену контекста можно обрабатывать через канал <-context.Done(), который уведомляет об отмене контекста.

    </details>

  ---

  </details>

<!-- Garbage Collector -->
- <details>
    <summary><h3><i>Garbage Collector</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое сборщик мусора и по какому алгоритму он реализован в Go? ]

    <details>
      <summary>Ответ</summary>

        - Любую аллоцированную память необходимо очищать после окончания ее использования. В некоторых языках 
          программирования разработчик сам должен управлять этим процессом. В Go неиспользуемые объекты находит и удаляет
          сборщик мусора. Сборщик мусора - устроен по алгоритму Mark and Sweep
    </details>

  ---

  - Вопрос №2: [ Расскажите про алгоритм mark and sweep ]

    <details>
      <summary>Ответ</summary>

        - Алгоритм Mark and Sweep состоит из двух частей:
        * Mark разметка.
        * Sweep очистка памяти. 
          Сама стадия Mark реализована с помощью 3 цветного алгоритма. Для наглядности представим, что все наши данные 
          лежат в виде графа, все узлы графа помечаем белым цветом. 
          Алгоритм:
          идет сканирование объектов первого уровня доступа, тех которые хранятся либо глобально, либо в стэке потока;
          объекты первого уровня помечаются серым цветом;
          в каждом сером объекте ищутся ссылки на области памяти;
          объекты по ссылкам помечаются серым;
          сам родительский элемент помечается черным;
          процесс повторяется, пока не останется серых объектов (белые объекты будем удалять на следующем шаге).

    </details>

  ---

  - Вопрос №3: [ Когда запускается сборщик мусора? ]

    <details>
      <summary>Ответ</summary>

        - По умолчанию сборщик мусора запускается в тот момент, когда heap увеличился вдвое. 
          Этот параметр также можно настроить с помощью переменной среды окружения GOGC. 
          Вручную сборщик мусора можно запустить с помощью runtime.GC()
    </details>

  ---

  - Вопрос №4: [ Сколько ресурсов потребляет сборщик мусора? ]

    <details>
      <summary>Ответ</summary>

        - Сборщик мусора потребляет до 25% CPU для фазы Mark. Помимо этого за цикл работы сборщика мусора два раза 
          происходит остановка приложения (вызов stop the world).
    </details>

  ---

  </details>

<!-- ООП в Golang -->
- <details>
    <summary><h3><i>ООП в Golang</i></h3></summary>

  ---

  - Вопрос №1: [ Как реализовано ООП в golang? ]

    <details>
      <summary>Ответ</summary>

        - Как реализовано наследование?
          Как такового наследования в go нет, но при этом у нас есть структуры - это специальные типы, в которые мы 
          можем включать другие типы, в том числе такие же структуры. При этом методы дочерних структур родительская 
          структура также будет наследовать.
          Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?
          Реализация родительского метода будет переписана реализацией дочернего метода.
          
        - Как реализована Инкапсуляция?
          Инкапсуляция в go - это возможность задавать переменным, функциям и методам первую букву названия в верхнем 
          или нижнем регистре. Соответственно нижний регистр будет значить, что переменная, функция или метод доступна 
          только в рамках пакета. Тогда как верхний регистр даст доступ к переменной, функции или методу за рамками пакета.
          
        - Как реализован Полиморфизм?
          Полиморфизм в go реализован с помощью интерфейсов. Основная идея заключается в том, что мы можем объявить 
          интерфейсы (контракты на определённое поведение) для наших типов. При этом, для типов мы должны реализовать 
          методы, удовлетворяющие этим интерфейсам. Таким образом, мы сможем работать со всем набором типов, у которых 
          реализовали интерфейсы, как с единым интерфейсным типом.
    </details>

  ---

  </details>

<!-- Ошибки и паники Golang -->
- <details>
    <summary><h3><i>Ошибки и паники Golang</i></h3></summary>

  ---

  - Вопрос №1: [ Обработка ошибок в go, есть ли исключения, как работать с panic? ]

    <details>
      <summary>Ответ</summary>

        - В Go нет традиционной системы исключений, как в некоторых других языках программирования (например, Java или Python).
          Вместо этого Go предпочитает явную обработку ошибок с помощью возвращаемых значений. В Go типичный способ 
          бработки ошибок — это возврат ошибки в качестве одного из возвращаемых значений функции.

          Panic и Recover
          Хотя исключений нет, в Go есть механизмы panic и recover, которые используются для обработки и восстановления 
          после критических ошибок (обычно это ошибки, которые программист не предвидел или не может корректно обработать).

        - "panic" останавливает нормальное выполнение функций и начинает прокладывать путь обратно по стеку вызовов, 
          выполняя при этом defer-вызовы.
        - "recover" используется для перехвата значения, переданного panic, должен быть вызван внутри defer он возвращает
          значение паники, после этого паника прекращается, и выполнение программы продолжается с инструкции, 
          следующей за вызовом паничной функции, которая привела к панике

          Принципы обработки ошибок в Go
        * Явность превыше всего: Явная проверка ошибок делает код более понятным.
        * Не игнорируйте ошибки: В отсутствие исключений игнорирование возвращаемого значения ошибки является плохой практикой.
        * Используйте panic только для критических ошибок: Это не замена обычной обработке ошибок.
    </details>

  ---

  </details>

</details>

<!-- Алгоритмы -->
<details>
    <summary><h2><i>Алгоритмы</i></h2></summary>

---

Вопрос №1: [ Как отсортировать файл на 100GB с 1GB ОЗУ? ]

<details>
  <summary>Ответ</summary>

    - Используйте внешнюю сортировку:
    - Разделите большой файл на меньшие части размером < 1GB.
    - Отсортируйте каждую часть в памяти и сохраните на диск.
    - Объедините отсортированные части, считывая и сравнивая первые элементы каждого файла. 
</details>

---

</details>
