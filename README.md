# Go Interview Questions 2023
Репозиторий предназначен для подготовки к собеседованиям на позицию Backend разработчика на языке Go.  
В данном Readme собраны (частые и не очень вопросы) и ответы к ним. Вопросы сгрупированы по темам.

Настоятельно рекомендую, прежде чем открывать ответ на вопрос, подумать и попробовать ответить на него самостоятельно.

P.S  
Если вы нашли не точность либо у вас есть свои вопросы которые в ыхотели бы добавить, обязательно пишите и не стесняйтесь!!!

---

# Вопросы и ответы

<!-- ОБЩЕЕ -->
<details>
    <summary><h2><i>Общее</i></h2></summary>

---

Вопрос №1: [ Что такое микросервисы? ]

<details>
  <summary>Ответ</summary>

    - Микросервисы — это подход к разработке программного обеспечения, при котором большое приложение разбивается на меньшие, автономные компоненты. 
    Каждый микросервис представляет собой отдельный модуль, который реализует определенный функционал и может работать независимо от других модулей. 
    Эти модули обычно взаимодействуют друг с другом через API или событийно-ориентированную архитектуру.

</details>

---

Вопрос №2: [ Какие преимущества у микросервисной архитектуры по сравнению с монолитом? А какие недостатки? ]

<details>
  <summary>Ответ</summary>

    - Преимущества:
        - Гибкость: Можно использовать разные технологии и языки программирования для разных микросервисов.
        - Масштабируемость: Легче масштабировать отдельные компоненты.
        - Распределение работы: Разные команды могут работать над разными сервисами параллельно.
        - Быстрый цикл разработки: Изменения в одном микросервисе могут быть развернуты независимо от других.
        
    - Недостатки:
        - Сложность: Взаимодействие между микросервисами может стать сложным и трудным для управления.
        - Проблемы с данными: Труднее обеспечить консистентность данных между сервисами.
        - Сложность тестирования: Тестирование может быть сложнее, особенно для сценариев, которые требуют взаимодействия между множеством сервисов.
</details>

---

Вопрос №3: [ Что использовать для трассировки сервисов? Для мониторинга? А для логирования? ]

<details>
  <summary>Ответ</summary>

    - Трассировка: Jaeger, Zipkin.
    - Мониторинг: Prometheus, Grafana, Zabbix.
    - Логирование: ELK Stack (Elasticsearch, Logstash, Kibana), Grafana Loki.
</details>

---

Вопрос №4: [ Как быть с консистентностью данных между несколькими микросервисами? ] <a name="micro2"></a>

<details>
  <summary>Ответ</summary>

    - Консистентность данных в микросервисной архитектуре — сложная задача. Один из подходов — использование распределенных транзакций, но это может привести к проблемам производительности и доступности. 
      Другой подход — "eventual consistency", где система стремится обеспечить консистентность данных в течение некоторого времени. 
      Для этого часто используют шины сообщений и системы очередей, такие как Kafka или RabbitMQ, чтобы синхронизировать данные между сервисами.
</details>

---

Вопрос №5: [ Что такое сине-зеленый деплой (Blue-Green Deployment)? ]

<details>
  <summary>Ответ</summary>

    - Сине-зеленый деплой — это метод развертывания приложений, при котором создается полностью независимое окружение (зеленое), идентичное текущему
    продуктивному(синему). После проверки новой версии приложения в зеленом окружении, трафик переключается на это окружение, сделав его новым продуктивным. 
    Этот метод позволяет мгновенно откатываться к предыдущей версии, если что-то пошло не так, так как синее окружение остается нетронутым.
    
    Преимущества:
      - Быстрый откат: Если в новой версии есть проблемы, можно быстро вернуться к старой версии.
      - Нулевое время простоя: Переключение трафика происходит мгновенно, что исключает простои.
</details>

---

Вопрос №6: [ Что такое системы оркестрации контейнеров? ]

<details>
  <summary>Ответ</summary>

    - Системы оркестрации контейнеров, такие как Kubernetes, Docker Swarm или Mesos, используются для автоматизации развертывания, масштабирования 
      и управления контейнеризованными приложениями.

    Для чего они нужны:
      - Автоматизация развертывания: Один раз описав как должен работать ваш сервис, вы можете автоматически развернуть его на любом числе машин.
      - Масштабирование: Вам не нужно вручную добавлять или удалять контейнеры. Оркестратор может делать это автоматически, в зависимости от нагрузки.
      - Балансировка нагрузки: Оркестраторы могут автоматически распределять входящий трафик между контейнерами одного сервиса.
      - Высокая доступность: Оркестраторы могут перезапускать упавшие контейнеры и перемещать их между хостами.
      - Обновление и откат: Оркестраторы могут обновлять приложения с минимальными простоями, а также откатывать их до предыдущих версий.

    Эти возможности делают системы оркестрации ключевым компонентом для современных облачных и микросервисных архитектур.
</details>

---

Вопрос №7: [ Что такое рефлексия? ]

<details>
  <summary>Ответ</summary>

    - Рефлексия в программировании — это механизм, который позволяет программам исследовать информацию о типах и структурах данных во время выполнения. 
      В Go рефлексия основана на двух ключевых типах: Type и Value, которые определены в пакете reflect.
      
    С помощью рефлексии можно:
      - Определять тип переменной во время выполнения.
      - Исследовать структуры и их поля, интерфейсы, значения массивов и множество других аспектов данных.
      - Создавать новые значения, изменять их и вызывать методы на них динамически.

    Зачем это нужно?
    Рефлексия часто используется в ситуациях, где типы данных неизвестны до времени выполнения. Например, она полезна при работе с библиотеками для маршалинга
    и анмаршалинга данных (например, JSON, XML), создании ORM, фреймворков для тестирования и многом другом.

    Осторожно!!!
    Несмотря на свою мощь, рефлексию следует использовать осторожно:
      - Производительность: Рефлексивные операции обычно медленнее, чем их нерефлексивные аналоги.
      - Читаемость кода: Рефлексия может сделать код сложнее для понимания и поддержки.
      - Типобезопасность: Рефлексия может привести к ошибкам во время выполнения из-за неправильного использования типов или несуществующих полей/методов.

    Таким образом, рефлексия — мощный, но "острый" инструмент, и его следует использовать разумно.
</details>

---

Вопрос №8: [ Что такое асинхронность? ]

<details>
  <summary>Ответ</summary>

    - Вычисления в системе могут идти двумя способами:
        - синхронно - это когда код выполняется последовательно;
        - асинхронно - это когда операцию мы можем выполнять не дожидаясь результата на месте. Обычно подразумевается, что операция может быть выполнена кем-то на стороне.
</details>

---

Вопрос №9: [ Что такое параллельность? ]

<details>
  <summary>Ответ</summary>

    - Вычисления будут являться параллельным только в том случае, если они выполняются одновременно. 
      Как пример можно привести процесс ремонта в доме. У нас есть несколько мастеров-универсалов, 
      каждый из которых выполняет работы на своем объекте под ключ. При этом производительность мастеров не зависит друг от друга, 
      так как их работа не пересекается.
</details>

---

Вопрос №10: [ Что такое конкурентность? ]

<details>
  <summary>Ответ</summary>

    - Конкурентность обеспечивает выполнение нескольких задач посредством переключения контекста. 
      Конкурентные вычисления реализуются на одном ядре системы. Как пример приведем тот же процесс ремонта, но с другими вводными условиями. 
      Теперь мы имеем один объект, на который привлекаем специалистов разного профиля: по демонтажным работам, электрике, подготовке стен и полов, отделке. 
      При этом у нас часто возникают ситуации, когда хозяин уже в процессе подготовки стен, решает, что вот эта стена ему все же не нужна, и на сцену опять выходят демонтажники. 
      Такой процесс организации работ можно назвать конкурентным, так как наши мастера уступают место друг другу, одновременно клеить обои и ломать стены они не могут.
</details>

---

</details>

<!-- Сеть и всё что с ней связано -->
<details>
    <summary><h2><i>Сеть и всё что с ней связано</i></h2></summary>

---

Вопрос №1: [ В чем отличие протоколов TCP и UDP? ]

<details>
   <summary>Ответ</summary>

    - TCP (Transmission Control Protocol)
        - Ориентирован на установление надежного соединения.
        - Ошибки корректируются; потерянные или поврежденные пакеты пересылаются.
        - Поддерживает управление потоком и перегрузкой.
        - Нормально работает в условиях высокой задержки.

    - UDP (User Datagram Protocol)
        - Безусловный протокол, не устанавливает соединение.
        - Ошибки не корректируются; потерянные пакеты не восстанавливаются.
        - Не поддерживает управление потоком и перегрузкой.
        - Обычно быстрее, чем TCP.

    - Когда UDP предпочтительнее:
        - Потоковое медиа, онлайн-игры, VoIP — там, где задержка критична и потеря пакетов допустима.
</details>

---

Вопрос №2: [ Какие еще протоколы существуют? ]

<details>
  <summary>Ответ</summary>

    - Транспортный уровень (как TCP и UDP):
        - SCTP (Stream Control Transmission Protocol) — протокол, предназначенный для передачи данных с поддержкой множественных потоков и устойчивый к ошибкам.
        - CCP (Datagram Congestion Control Protocol) — протокол, предназначенный для передачи потоковых медиа.

    - Сетевой уровень:
        - IP (Internet Protocol) — протокол маршрутизации.
        - ICMP (Internet Control Message Protocol) — протокол управляющих сообщений.
        - OSPF (Open Shortest Path First) — протокол динамической маршрутизации.

    - Канальный уровень:
        - Ethernet — наиболее распространенный протокол канального уровня.
        - Wi-Fi — набор стандартов для беспроводных локальных сетей.

    - Прикладной уровень:
        - HTTP/HTTPS (HyperText Transfer Protocol/Secure) — протокол передачи гипертекста.
        - FTP (File Transfer Protocol) — протокол передачи файлов.
        - SMTP (Simple Mail Transfer Protocol) — протокол для передачи электронной почты.
        - DNS (Domain Name System) — система преобразования доменных имен в IP-адреса.
        - MQTT (Message Queuing Telemetry Transport) — протокол мессенджинга для IoT устройств.
        - Это далеко не исчерпывающий список, и существует множество других протоколов для различных специфических задач и сценариев использования.

</details>

---

</details>

<!-- Операционная система -->
<details>
    <summary><h2><i>Операционная система</i></h2></summary>

---

Вопрос №1: [ Можно ли убить поток внутри определенного процесса командой kill? ]

<details>
  <summary>Ответ</summary>

    - Обычно команда kill убивает процессы, а не отдельные потоки. В Linux потоки являются частью процесса и не могут быть убиты независимо от него командой kill.
</details>

---

</details>

<!-- Базы данных -->
<details>
    <summary><h2><i>Базы данных</i></h2></summary>

---

Вопрос №1: [ Какая разница между реляционными vs не реляционными СУБД? ]

<details>
  <summary>Ответ</summary>

    - SQL:
        Плюсы:
          - Строгая схема: Помогает в поддержании целостности данных.
          - ACID-свойства: Поддержка транзакций с гарантированной Атомарностью, Согласованностью, Изолированностью и Долговечностью.
          - SQL: Богатый язык запросов, хорошо подходящий для сложных запросов.
          - Широкая поддержка: Огромное сообщество, много документации и инструментов.
          - Зрелость: Проверенные временем, надежные решения.
        Минусы:
          - Горизонтальное масштабирование: Обычно сложнее масштабировать горизонтально по сравнению с NoSQL.
          - Сложность: SQL и реляционные схемы могут быть сложными для новичков.
          - Стоимость: Коммерческие решения могут быть дорогими.

    - NoSQL:
        Плюсы:
          - Масштабируемость: Обычно проще масштабировать горизонтально.
          - Гибкость схемы: Можно легко добавлять поля в данные.
          - Высокая производительность: Оптимизированы для больших данных и реального времени.
          - Разнообразие моделей данных: ключ-значение, документ-ориентированные, колоночные и графовые базы данных.
        Минусы:
          - Недостаток стандартизации: Множество разных систем с разными API.
          - Сложность: Распределенные системы приносят собой сложности в управлении и обслуживании.
          - Недостаточная поддержка транзакций: Не все NoSQL-системы поддерживают ACID-транзакции.
        
    - Когда выбрать NoSQL?
        - При необходимости горизонтального масштабирования.
        - Когда схема данных непостоянна или развивается со временем.
        - Для больших данных и обработки в реальном времени.

    - Какие NoSQL решения знаешь?
        - MongoDB, Cassandra, Redis, и Couchbase.
        
    - Трудности при работе с NoSQL:
        - Сложность управления распределенной системой.
        - Отсутствие стандартизированного языка запросов, как SQL.
        - Вопросы консистентности данных, особенно в распределенных системах.
</details>

---

</details>

<!-- Golang -->
<details>
    <summary><h2><i>Golang</i></h2></summary>

- <details>
    <summary><h3><i>Общие вопросы по языку Go</i></h3></summary>

  ---

  - Вопрос №1: [ Расскажи кратко о языке Go ]
    
    <details>
      <summary>Ответ</summary>
  
    </details>

  ---

  - Вопрос №2: [ Как реализовано хранилище памяти в Go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Какие типы данных есть в языке Go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Что такое пакеты в go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ Что такое глобальная переменная? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №6: [ Что такое константы и можно ли их изменять? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №7: [ Зачем фигурные скобки с не объявленным оператором внутри функции? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №8: [ В go есть оператор switch case, можно ли выполнить несколько условий в одном объявленном операторе? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №9: [ Что такое iota? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №10: [ Как вручную задать количество процессоров для приложения? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №11: [ Как принудительно переключить контекст? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №12: [ Что такое graceful shutdown? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №13: [ Что обозначает * и &? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №14: [ Как происходит передача параметров в функцию? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №15: [ Есть ли особенности поведения при передаче map и slice в функцию? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №16: [ Как функции делятся памятью? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Численные типы</i></h3></summary>

  ---

  - Вопрос №1: [ Какие численные типы есть? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Какой результат получим если разделить int на 0 и float на 0? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Строки</i></h3></summary>

  ---

  - Вопрос №1: [ Что представляют собой строки в go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Интерфейсы</i></h3></summary>

  ---

  - Вопрос №1: [ Интерфейсы: Что такое интерфейс в Go? Зачем нужен на практике? Примеры задач где стоит ввести? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Что такое пустой интерфейс? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Как устроен внутри nil интерфейс vs nil внутри интерфейса? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Как определить тип интерфейса? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ В каком пакете лучше объявлять интерфейсы и почему? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Массивы и слайсы</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое слайс и чем он отличается от массива? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Какой размер массива выделяется под слайс при его расширении за рамки его емкости? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Map</i></h3></summary>

  ---

  - Вопрос №1: [ Как реализована map(карта) go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Почему нельзя брать ссылку на значение, хранящееся по ключу в map? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Что такое эвакуация, и в каком случае она будет происходить? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Какие есть особенности синтаксиса получения и записи значений в map? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ Как происходит поиск по ключу в map? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Defer</i></h3></summary>

  ---

  - Вопрос №1: [ Зачем используется ключевое слово defer в go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Как передаются значения в функции, перед которыми указано ключевое слово defer? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Горутины</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое поток и горутина? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Сколько можно запустить потоков и горутин? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Каков минимальный и максимальный вес горутин? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Что будет если размер горутины превысил допустимый максимум? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ Какие есть способы остановить все горутины в приложении? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №6: [ Как наладить связь между горутинами? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Примитивы синхронизации</i></h3></summary>

  ---

  - Вопрос №1: [ Какие есть примитивы синхронизации? Расскажи немного про каждый ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Что такое channel? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Что такое буферизированный и небуферизированный channel? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Какие действия можно произвести с каналом? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ Что будет если писать/читать в nil channel? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №6: [ Что будет если писать/читать в/из закрытый channel? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №7: [ Как закрыть channel? Что с ним происходит? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №8: [ Какие есть инструкции для чтения из channel? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Switch/Select/Case</i></h3></summary>

  ---

  - Вопрос №1: [ Как сделать select неблокирующим? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Какой порядок исполнения операций case в select? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Context</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое context в GO? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Для чего применяется context? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Чем отличается context.Background от context.TODO? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Как передавать значения и вычитывать их из context? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №5: [ Каковы отличия context.WithCancel, context.WithDeadline, context.WithTimeout? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №6: [ Как обрабатывать отмену context? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>Garbage Collector</i></h3></summary>

  ---

  - Вопрос №1: [ Что такое сборщик мусора и по какому алгоритму он реализован в Go? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №2: [ Расскажите про алгоритм mark and sweep ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №3: [ Когда запускается сборщик мусора? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  - Вопрос №4: [ Сколько ресурсов потребляет сборщик мусора? ]

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

- <details>
    <summary><h3><i>ООП в Golang</i></h3></summary>

  ---

  - Вопрос №1:

    <details>
      <summary>Ответ</summary>

    </details>

  ---

  </details>

</details>

<!-- Алгоритмы -->
<details>
    <summary><h2><i>Алгоритмы</i></h2></summary>

---

Вопрос №1: [ Как отсортировать файл на 100GB с 1GB ОЗУ? ]

<details>
  <summary>Ответ</summary>

    - Используйте внешнюю сортировку:
    - Разделите большой файл на меньшие части размером < 1GB.
    - Отсортируйте каждую часть в памяти и сохраните на диск.
    - Объедините отсортированные части, считывая и сравнивая первые элементы каждого файла. 
</details>

---

</details>
